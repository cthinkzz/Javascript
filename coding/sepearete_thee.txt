let x = 'abbba';
let y = 'bba';

const checkSubstring = (x, y) => {
  const yLen = y.length;
  let found = false;
  for (let i = 0; i < x.length; i++) {
    let j = 0;
    let k = i;
    while (j < yLen) {
      if (x[k] === y[j]) {
        j++;
        k++;
      } else {
        break;
      }
    }
    if (j === yLen) {
      found = true;
      break;
    }
  }
  console.log('found', found);
};
checkSubstring('abbcba', 'bbcba');










const str = 'abcdeapq';

const maximumSubstring = () => {
  const len = str.length;
  let maxString = '';
  for (let i = 0; i < len - 1; i++) {
    let substr = str[i];
    const charSet = { [substr]: true };
    for (let j = i + 1; j < len; j++) {
      if (charSet[str[j]]) {
        break;
      } else {
        substr = substr + str[j];
        charSet[str[j]] = true;
      }
    }
    if (maxString.length < substr.length) {
      maxString = substr;
    }
  }

  console.log('Maximum non repitative substring is ', maxString);
};

maximumSubstring('abcdeapq');






https://jsfiddle.net/mo43xsny/7/	

const LIMIT = 5;
const FetchWrapper = () => {
  let count = 0;
  let queue = [];

  const callback = () => {
    let tempCount = 0;
    if (count < LIMIT) {
      for (let item of queue) {
        if (count < LIMIT) {
          count++;
          const { url, options, resolve, reject } = item;
          try {
            const resp = fetch(url, options);
            resolve(resp);
          } catch (err) {
            reject(err);
          }
        }
        queue = queue.slice(0, tempCount);
      }
    }
  };

  return function (url, options) {
    if (count < LIMIT) {
      count++;
      return fetch(url, options)
        .then((data) => {
          count--;
          callback();
          return new Promoise.resolve(data);
        })
        .catch((err) => {
          count--;
          callback();
          return new Promoise.reject(error);
        });
    } else {
      return new Promise((resolve, reject) => {
        queue.push({ url, options, resolve, reject });
      });
    }
  };
};

const myFetch = FetchWarpper();
myFetch(url, options)
  .then(() => {})
  .catch(() => {});
myFetch(url, options);
myFetch(url, options);
myFetch(url, options);
myFetch(url, options);

myFetch(url, options);
